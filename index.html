<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>G-MATH - Â§ö‰∫∫ËÅîÊú∫Áâà</title>
    <style>
        :root {
            /* Âü∫Á°ÄÈ¢úËâ≤ */
            --board-bg: #f0f0f0;
            --tile-bg: #fdf5e6;
            --tile-color: #333;
            --dl-color: #a8e6cf;
            --tl-color: #3d84a8;
            --dw-color: #ffaaa5;
            --tw-color: #ff8b94;
            --accent: #4a4e69;
            --dark-bg: #22223b;
            /* Ê†∏ÂøÉÂèòÈáèÔºöÊ†πÊçÆÂ±èÂπïÂ§ßÂ∞èËÆ°ÁÆóÊ†ºÂ≠êÂ∞∫ÂØ∏ */
            --cell-size: min(calc((100vh - 80px) / 15), calc(60vw / 15));
            --sidebar-padding: 20px;
        }

        @media (orientation: portrait) {
            :root {
                --cell-size: calc((100vw - 20px) / 15);
                --sidebar-padding: 10px;
            }
        }

        * { box-sizing: border-box; }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--dark-bg);
            color: white;
            margin: 0;
            padding: 0;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        @media (orientation: portrait) {
            body { height: auto; min-height: 100vh; overflow-y: auto; }
        }

        header {
            height: 50px; background: #1a1a2e; display: flex; align-items: center; justify-content: space-between;
            padding: 0 20px; box-shadow: 0 2px 5px rgba(0,0,0,0.2); flex-shrink: 0; z-index: 20; position: relative;
        }
        h1 { margin: 0; font-size: 1.2rem; display: flex; align-items: center; gap: 10px; }

        #lobby-screen, #config-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: var(--dark-bg); z-index: 1000;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            padding: 20px; text-align: center;
        }
        .lobby-card {
            background: white; color: #333; padding: 40px; border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5); width: 100%; max-width: 450px;
        }
        .lobby-input, textarea {
            width: 100%; padding: 12px; margin: 10px 0;
            border: 2px solid #ddd; border-radius: 8px; font-size: 1rem;
            font-family: monospace;
        }
        .lobby-btn {
            width: 100%; padding: 12px; margin: 5px 0;
            border: none; border-radius: 8px; font-size: 1rem; font-weight: bold;
            cursor: pointer; transition: 0.2s; color: white;
        }
        .btn-create { background: #2a9d8f; }
        .btn-join { background: #457b9d; }
        .btn-save { background: #e76f51; }
        .btn-start { background: #e76f51; margin-top: 20px;}

        #game-ui { display: none; width: 100%; height: 100%; flex: 1; }
        .main-wrapper { flex: 1; display: flex; padding: 10px; width: 100%; height: 100%; align-items: center; justify-content: center; gap: 2vw; }
        @media (orientation: portrait) { .main-wrapper { flex-direction: column; height: auto; justify-content: flex-start; } }

        .board-area { flex-shrink: 0; background: #4a4e69; padding: 6px; border-radius: 8px; box-shadow: 5px 5px 20px rgba(0,0,0,0.4); }
        #game-board { display: grid; grid-template-columns: repeat(15, var(--cell-size)); grid-template-rows: repeat(15, var(--cell-size)); gap: 2px; background-color: #333; border: 2px solid #333; }
        .cell { background-color: var(--board-bg); display: flex; justify-content: center; align-items: center; font-size: calc(var(--cell-size) * 0.28); color: #333; font-weight: bold; position: relative; user-select: none; cursor: pointer; }
        .cell.dl { background-color: var(--dl-color); color: #004d40; }
        .cell.tl { background-color: var(--tl-color); color: white; }
        .cell.dw { background-color: var(--dw-color); color: #880e4f; }
        .cell.tw { background-color: var(--tw-color); color: #880e4f; }
        .cell.center { background-color: var(--dw-color); font-size: calc(var(--cell-size) * 0.6); }

        .tile { width: calc(var(--cell-size) - 4px); height: calc(var(--cell-size) - 4px); background-color: var(--tile-bg); border-radius: 4px; display: flex; justify-content: center; align-items: center; font-size: calc(var(--cell-size) * 0.55); font-weight: bold; color: var(--tile-color); box-shadow: 2px 2px 4px rgba(0,0,0,0.2); cursor: grab; z-index: 10; position: relative; }
        .tile span.points { position: absolute; bottom: 2px; right: 3px; font-size: calc(var(--cell-size) * 0.25); color: #666; }
        .tile.temp { border: 2px solid #4caf50; box-shadow: 0 0 5px #4caf50; }
        .tile.locked { cursor: default; background-color: #ddd; color: #555; }
        .tile.selected { transform: translateY(-8px) scale(1.1); border: 2px solid #ffd700; box-shadow: 0 0 15px rgba(255, 215, 0, 0.9); z-index: 20; background-color: #fffbf0; }
        .rack-swapping { background: rgba(233, 196, 106, 0.2) !important; border: 2px dashed #e9c46a !important; }

        .sidebar { flex: 1; height: calc(15 * var(--cell-size) + 12px); min-width: 320px; display: flex; flex-direction: column; gap: 10px; }
        @media (orientation: portrait) { .sidebar { width: 100%; height: auto; flex: none; } }
        .panel { background: rgba(255,255,255,0.07); padding: 10px; border-radius: 12px; backdrop-filter: blur(5px); border: 1px solid rgba(255,255,255,0.1); }

        .player-row { display: flex; justify-content: space-between; align-items: center; padding: 10px 5px; font-size: 0.9rem; border-bottom: 1px solid rgba(255,255,255,0.05); border-radius: 4px; gap: 8px; }
        .p-name { flex: 0 0 auto; width: 70px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; font-weight: 500; }
        .mini-rack { flex: 1; display: flex; gap: 3px; justify-content: flex-start; flex-wrap: wrap; padding: 0 5px; }
        .mini-tile { width: 24px; height: 24px; background-color: #fdf5e6; color: #333; border-radius: 3px; font-size: 14px; font-weight: bold; display: flex; justify-content: center; align-items: center; box-shadow: 1px 1px 2px rgba(0,0,0,0.3); cursor: default; }
        .p-score { flex: 0 0 auto; font-weight: bold; text-align: right; width: 40px; }
        .player-row.active { background: linear-gradient(90deg, rgba(255,215,0,0.2) 0%, transparent 100%); color: #ffd700; font-weight: bold; border-left: 4px solid #ffd700; }
        .player-row.eliminated { opacity: 0.5; background: rgba(0,0,0,0.3); color: #aaa; }
        .player-row.eliminated .p-name { text-decoration: line-through; }
        .player-row.eliminated .mini-tile { background-color: #ccc; color: #777; }

        .actions { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; }
        button { padding: 12px 5px; border: none; border-radius: 8px; font-weight: bold; cursor: pointer; transition: all 0.2s; font-size: 0.9rem; text-transform: uppercase; color: white; box-shadow: 0 4px 6px rgba(0,0,0,0.2); }
        button:active { transform: translateY(2px); box-shadow: 0 1px 2px rgba(0,0,0,0.2); }
        button:disabled { opacity: 0.3; cursor: not-allowed; filter: grayscale(100%); }
        .btn-play { background: #2a9d8f; grid-column: span 3; }
        .btn-swap { background: #e9c46a; color: #333; }
        .btn-swap.active { background: #ffca3a; box-shadow: inset 0 0 10px rgba(0,0,0,0.2); animation: pulse 2s infinite; }
        .btn-reset { background: #e76f51; }
        .btn-pass { background: #264653; }
        .btn-shuffle { background: #457b9d; grid-column: span 2; font-size: 0.8rem; opacity: 0.9;} 
        .btn-help { background: #607d8b; grid-column: span 1; font-size: 0.8rem; opacity: 0.9; }

        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.02); } 100% { transform: scale(1); } }
        #message-area { text-align: center; color: #ffd700; font-weight: bold; padding: 10px; background: rgba(0,0,0,0.4); border-radius: 6px; font-size: 1rem; }
        .legend { display: flex; justify-content: space-around; font-size: 0.75rem; padding: 10px; }
        .legend div { display: flex; align-items: center; gap: 5px; }

        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); justify-content: center; align-items: center; z-index: 100; }
        .modal-content { background: white; color: #333; padding: 30px; border-radius: 15px; text-align: center; box-shadow: 0 10px 30px rgba(0,0,0,0.5); max-width: 600px; width: 90%; max-height: 85vh; overflow-y: auto; position: relative; }
        .input-group { margin-bottom: 15px; text-align: left; }
        .input-group label { display: block; margin-bottom: 5px; font-weight: bold; color: #555; }
        .input-group input { width: 100%; padding: 10px; border: 2px solid #ddd; border-radius: 6px; font-size: 1rem; transition: border 0.2s; }
        .input-group input:focus { border-color: #2a9d8f; outline: none; }
        .tutorial-section { text-align: left; margin-bottom: 20px; padding: 10px; background: #f9f9f9; border-radius: 8px; }
        .tutorial-section h3 { color: #2a9d8f; border-bottom: 2px solid #eee; padding-bottom: 5px; margin-top: 0;}
        .tutorial-list { padding-left: 20px; margin: 10px 0; }
        .key-point { font-weight: bold; color: #e76f51; }
        .close-btn { position: absolute; top: 15px; right: 20px; font-size: 1.5rem; cursor: pointer; color: #999; }
        .endgame-table { width: 100%; border-collapse: collapse; margin: 20px 0; }
        .endgame-table th, .endgame-table td { padding: 10px; border-bottom: 1px solid #ddd; }
        .endgame-table th { background: #f0f0f0; color: #333; }
        .score-change.negative { color: #e76f51; }
        .score-change.positive { color: #2a9d8f; font-weight: bold; }

        #remaining-info { cursor: help; position: relative; padding: 5px 0; }
        #remaining-tooltip { display: none; position: absolute; top: 100%; right: 0; width: 340px; background: rgba(30, 30, 50, 0.95); border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; padding: 12px; z-index: 1000; box-shadow: 0 8px 20px rgba(0,0,0,0.6); flex-wrap: wrap; gap: 6px; justify-content: flex-start; margin-top: 5px; backdrop-filter: blur(5px); }
        #remaining-info:hover #remaining-tooltip { display: flex; }
        #remaining-info:active #remaining-tooltip { display: flex; }
        #remaining-tooltip::after { content: ''; position: absolute; bottom: 100%; right: 20px; border-width: 6px; border-style: solid; border-color: transparent transparent rgba(30, 30, 50, 0.95) transparent; }
        .tiny-tile { width: 34px; height: 34px; background: #fdf5e6; color: #333; font-size: 18px; font-weight: bold; display: flex; justify-content: center; align-items: center; border-radius: 4px; box-shadow: 1px 1px 3px rgba(0,0,0,0.5); }
        .tiny-tile.op { background: #e3f2fd; color: #0d47a1; }
        
        #rack-container { min-height: calc(var(--cell-size) * 1.2 + 10px); padding: 5px; }
    </style>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, onSnapshot, updateDoc, arrayUnion, increment } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-firestore.js";

        // ==================================================
        // üî¥ Â∑≤‰∏∫ÊÇ®Ëá™Âä®Â°´ÂÖ•ÈÖçÁΩÆÔºåÁõ¥Êé•‰øùÂ≠òÂç≥ÂèØ
        // ==================================================
        const MANUAL_FIREBASE_CONFIG = {
            apiKey: "AIzaSyDFG6-ixcZPWxFdApAfd6_ftsJkeOs8vaQ",
            authDomain: "g-math-pvp.firebaseapp.com",
            projectId: "g-math-pvp",
            storageBucket: "g-math-pvp.firebasestorage.app",
            messagingSenderId: "552556975122",
            appId: "1:552556975122:web:7b10b3450a6e95806df4cb",
            measurementId: "G-V503SCHF31"
        };

        // --- Config Handling ---
        let app, auth, db, APP_ID;

        async function initSystem() {
            // 1. ‰ºòÂÖà‰ΩøÁî®Á°¨ÁºñÁ†ÅÁöÑÈÖçÁΩÆ
            let config = MANUAL_FIREBASE_CONFIG;

            // 2. Â¶ÇÊûúÊúâÈÖçÁΩÆÔºåÊ∏ÖÈô§ÂèØËÉΩÂ≠òÂú®ÁöÑÈîôËØØÁºìÂ≠òÔºåÈò≤Ê≠¢ÂÜ≤Á™Å
            if (config) {
                localStorage.removeItem('gmath_firebase_config');
            }
            
            // 3. Initialize Firebase
            try {
                app = initializeApp(config);
                auth = getAuth(app);
                db = getFirestore(app);
                APP_ID = (typeof __app_id !== 'undefined') ? __app_id : 'gmath-v1';
                
                // Auth Flow
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                     await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                     await signInAnonymously(auth);
                }
            } catch (e) {
                alert("Firebase ÂàùÂßãÂåñÂ§±Ë¥•: " + e.message + "\n\nËØ∑Ê£ÄÊü•Ôºö\n1. FirebaseÊéßÂà∂Âè∞‰∏≠ÊòØÂê¶ÂºÄÂêØ‰∫Ü'Authentication' -> 'Anonymous'?\n2. ÊòØÂê¶ÂºÄÂêØ‰∫Ü'Firestore Database'?");
                return;
            }

            // Success
            onAuthStateChanged(auth, (user) => {
                if (user) {
                    currentUser = user;
                    document.getElementById('lobby-loading').style.display = 'none';
                    document.getElementById('lobby-screen').style.display = 'flex';
                    document.getElementById('lobby-content').style.display = 'block';
                }
            });
        }

        // --- Global State ---
        let currentUser = null;
        let currentRoomId = null;
        let unsubscribeRoom = null;
        let myPlayerIndex = -1;
        
        // Game Config
        const BOARD_SIZE = 15;
        const RACK_SIZE = 8;
        const TILE_CONFIG = {
            '0':6, '1':6, '2':6, '3':6, '4':6, '5':6, '6':6, '7':6, '8':6, '9':6,
            '+':7, '-':7, '√ó':7, '√∑':7, '=':20
        };
        const SCORES = {
            '0':1, '1':1, '2':2, '3':2, '4':2, '5':3, '6':3, '7':4, '8':4, '9':4,
            '+':2, '-':2, '√ó':4, '√∑':4, '=':1
        };

        const SPECIAL_CELLS = {
            'TW': ['0,0', '0,7', '0,14', '7,0', '7,14', '14,0', '14,7', '14,14'],
            'DW': ['1,1', '2,2', '3,3', '4,4', '10,10', '11,11', '12,12', '13,13', '1,13', '2,12', '3,11', '4,10', '10,4', '11,3', '12,2', '13,1'],
            'TL': ['1,5', '1,9', '5,1', '5,5', '5,9', '5,13', '9,1', '9,5', '9,9', '9,13', '13,5', '13,9'],
            'DL': ['0,3', '0,11', '2,6', '2,8', '3,0', '3,7', '3,14', '6,2', '6,6', '6,8', '6,12', '7,3', '7,11', '8,2', '8,6', '8,8', '8,12', '11,0', '11,7', '11,14', '12,6', '12,8', '14,3', '14,11']
        };

        // --- Lobby Functions ---
        window.createRoom = async () => {
            const name = document.getElementById('nickname').value.trim() || "Player";
            const roomId = Math.random().toString(36).substring(2, 8).toUpperCase();
            currentRoomId = roomId;

            const initialData = {
                roomId: roomId,
                status: "waiting",
                players: [{
                    uid: currentUser.uid,
                    name: name,
                    score: 0,
                    rack: [],
                    misses: 0,
                    active: true
                }],
                currentPlayerIndex: 0,
                consecutivePasses: 0,
                tileBag: generateTileBag(),
                boardState: Array(BOARD_SIZE * BOARD_SIZE).fill(null),
                createdAt: new Date().toISOString()
            };

            const roomRef = doc(db, 'artifacts', APP_ID, 'public', 'data', 'rooms', roomId);
            await setDoc(roomRef, initialData);
            enterRoomUI(true); 
            subscribeToRoom(roomId);
        };

        window.joinRoom = async () => {
            const name = document.getElementById('nickname').value.trim() || "Player";
            const roomId = document.getElementById('room-code-input').value.trim().toUpperCase();
            if (!roomId) return alert("ËØ∑ËæìÂÖ•ÊàøÈó¥Âè∑");

            const roomRef = doc(db, 'artifacts', APP_ID, 'public', 'data', 'rooms', roomId);
            const snap = await getDoc(roomRef);

            if (!snap.exists()) return alert("ÊàøÈó¥‰∏çÂ≠òÂú®");
            const data = snap.data();
            if (data.status !== "waiting") return alert("Ê∏∏ÊàèÂ∑≤ÁªèÂºÄÂßãÊàñÁªìÊùü");
            if (data.players.length >= 4) return alert("ÊàøÈó¥Â∑≤Êª°");
            if (!data.players.some(p => p.uid === currentUser.uid)) {
                const newPlayer = {
                    uid: currentUser.uid,
                    name: name,
                    score: 0,
                    rack: [],
                    misses: 0,
                    active: true
                };
                await updateDoc(roomRef, { players: arrayUnion(newPlayer) });
            }
            currentRoomId = roomId;
            enterRoomUI(false);
            subscribeToRoom(roomId);
        };

        window.startGame = async () => {
            if (!currentRoomId) return;
            const roomRef = doc(db, 'artifacts', APP_ID, 'public', 'data', 'rooms', currentRoomId);
            const snap = await getDoc(roomRef);
            const data = snap.data();
            
            let bag = [...data.tileBag];
            let players = [...data.players];
            bag.sort(() => Math.random() - 0.5);

            players.forEach(p => {
                const res = drawTilesForPlayer(p.rack, bag);
                p.rack = res.rack;
                bag = res.bag;
            });

            await updateDoc(roomRef, { status: "playing", tileBag: bag, players: players });
        };

        // --- Game Logic (Data separation) ---
        
        let localGameState = null;
        let tempPlacedTiles = []; 
        let selectedTileIds = new Set();
        let isSwapping = false;

        function enterRoomUI(isHost) {
            document.getElementById('lobby-screen').style.display = 'none';
            document.getElementById('setup-modal').style.display = 'none'; // Ensure setups are closed
            document.getElementById('game-ui').style.display = 'flex'; 
            document.getElementById('room-id-display').innerText = `ÊàøÈó¥Âè∑: ${currentRoomId}`;
            if (!isHost) document.getElementById('host-controls').style.display = 'none';
        }

        function subscribeToRoom(roomId) {
            const roomRef = doc(db, 'artifacts', APP_ID, 'public', 'data', 'rooms', roomId);
            unsubscribeRoom = onSnapshot(roomRef, (doc) => {
                if (!doc.exists()) return;
                const data = doc.data();
                localGameState = data;
                myPlayerIndex = data.players.findIndex(p => p.uid === currentUser.uid);
                renderGame();
            });
        }

        // --- Core Game Rendering & Interaction ---

        function renderGame() {
            if (!localGameState) return;
            const currentPlayer = localGameState.players[localGameState.currentPlayerIndex];
            const isMyTurn = (localGameState.currentPlayerIndex === myPlayerIndex) && localGameState.status === 'playing';
            const statusEl = document.getElementById('status-bar');
            
            if (localGameState.status === 'waiting') {
                statusEl.innerText = `‚è≥ Á≠âÂæÖÊàø‰∏ªÂºÄÂßãÊ∏∏Êàè... (${localGameState.players.length}/4)`;
                statusEl.style.color = '#ffd700';
                disableAllButtons(true);
                if (myPlayerIndex === 0 && localGameState.players.length > 1) document.getElementById('btn-start-game').style.display = 'block';
            } else if (localGameState.status === 'finished') {
                 statusEl.innerText = "üèÜ Ê∏∏ÊàèÁªìÊùü";
                 disableAllButtons(true);
                 // Trigger End Game if we just transitioned
                 // (For simplicity, we check if modal is visible, if not show it)
                 // NOTE: A proper check would be better, but this works for MVP
                 if(document.getElementById('modal').style.display !== 'flex') {
                     endGameUI(localGameState);
                 }
            } else {
                 if (isMyTurn) {
                     statusEl.innerText = "üü¢ ËΩÆÂà∞‰Ω†‰∫ÜÔºÅËØ∑Âá∫Áâå";
                     statusEl.style.color = '#4caf50';
                     disableAllButtons(false);
                 } else {
                     statusEl.innerText = `üî¥ Á≠âÂæÖ ${currentPlayer.name} Âá∫Áâå...`;
                     statusEl.style.color = '#ff9800';
                     disableAllButtons(true);
                 }
                 document.getElementById('btn-start-game').style.display = 'none';
            }

            renderBoard();
            renderRack();
            renderScoreboard();
            renderRemainingInfo();
        }

        function renderBoard() {
            const boardEl = document.getElementById('game-board');
            boardEl.innerHTML = '';
            const boardData = localGameState.boardState;
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    const idx = r * BOARD_SIZE + c;
                    const cellData = boardData[idx];
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    const key = `${r},${c}`;
                    if (r===7 && c===7) { cell.classList.add('center'); cell.innerHTML='‚òÖ'; }
                    else if (SPECIAL_CELLS.TW.includes(key)) { cell.classList.add('tw'); cell.innerText='TW'; }
                    else if (SPECIAL_CELLS.DW.includes(key)) { cell.classList.add('dw'); cell.innerText='DW'; }
                    else if (SPECIAL_CELLS.TL.includes(key)) { cell.classList.add('tl'); cell.innerText='TL'; }
                    else if (SPECIAL_CELLS.DL.includes(key)) { cell.classList.add('dl'); cell.innerText='DL'; }

                    let tileToRender = cellData;
                    let isTemp = false;
                    const tempTile = tempPlacedTiles.find(t => t.r === r && t.c === c);
                    if (tempTile) { tileToRender = tempTile.tile; isTemp = true; }

                    if (tileToRender) {
                        cell.innerHTML = '';
                        const tileEl = createTileElement(tileToRender);
                        if (isTemp) tileEl.classList.add('temp'); else tileEl.classList.add('locked');
                        cell.appendChild(tileEl);
                    }
                    cell.onclick = () => handleBoardClick(r, c, tileToRender, isTemp);
                    boardEl.appendChild(cell);
                }
            }
        }

        function renderRack() {
            const rackContainer = document.getElementById('rack-container');
            rackContainer.innerHTML = '';
            if (myPlayerIndex === -1) return;
            const myRack = localGameState.players[myPlayerIndex].rack;
            if (isSwapping) rackContainer.classList.add('rack-swapping'); else rackContainer.classList.remove('rack-swapping');
            myRack.forEach(tileData => {
                const tileEl = createTileElement(tileData);
                if (selectedTileIds.has(tileData.id)) tileEl.classList.add('selected');
                tileEl.onclick = (e) => { e.stopPropagation(); handleRackClick(tileData); };
                rackContainer.appendChild(tileEl);
            });
        }

        function createTileElement(data) {
            const el = document.createElement('div');
            el.className = 'tile';
            el.innerHTML = `${data.char}<span class="points">${data.score}</span>`;
            return el;
        }

        function renderScoreboard() {
            const list = document.getElementById('players-list');
            list.innerHTML = '';
            localGameState.players.forEach((p, i) => {
                const div = document.createElement('div');
                const isActive = i === localGameState.currentPlayerIndex;
                div.className = `player-row ${isActive ? 'active' : ''} ${!p.active ? 'eliminated' : ''} ${i===myPlayerIndex ? 'me' : ''}`;
                
                const sortedRack = [...p.rack].sort((a, b) => {
                     const isNumA = /^[0-9]$/.test(a.char);
                     const isNumB = /^[0-9]$/.test(b.char);
                     if(isNumA && !isNumB) return -1;
                     if(!isNumA && isNumB) return 1;
                     return a.char.localeCompare(b.char);
                });

                let miniRackHtml = '<div class="mini-rack">';
                sortedRack.forEach(t => {
                     const isOp = !/^[0-9]$/.test(t.char);
                     miniRackHtml += `<div class="mini-tile" style="${isOp?'background:#e3f2fd;color:#0d47a1':''}">${t.char}</div>`;
                });
                miniRackHtml += '</div>';

                div.innerHTML = `
                    <span class="p-name">${p.name}</span> ${miniRackHtml} <span class="p-score">${p.score}</span>
                `;
                list.appendChild(div);
            });
        }

        function renderRemainingInfo() {
            const bag = localGameState.tileBag;
            const nums = bag.filter(t => /^[0-9]$/.test(t.char)).length;
            const ops = bag.length - nums;
            document.getElementById('tiles-left-header').innerText = `${bag.length} (Êï∞:${nums}|Á¨¶:${ops})`;
            const sortedBag = [...bag].sort((a, b) => {
                const isNumA = /^[0-9]$/.test(a.char);
                const isNumB = /^[0-9]$/.test(b.char);
                if(isNumA && !isNumB) return -1;
                if(!isNumA && isNumB) return 1;
                return a.char.localeCompare(b.char);
            });
            let html = '';
            sortedBag.forEach(t => {
                 const isOp = !/^[0-9]$/.test(t.char);
                 const opClass = isOp ? 'op' : '';
                 html += `<div class="tiny-tile ${opClass}">${t.char}</div>`;
            });
            document.getElementById('remaining-tooltip').innerHTML = html;
        }

        // --- Interaction Logic ---

        function handleRackClick(tile) {
            if (localGameState.currentPlayerIndex !== myPlayerIndex) return;
            if (isSwapping) {
                if (selectedTileIds.has(tile.id)) selectedTileIds.delete(tile.id); else selectedTileIds.add(tile.id);
            } else {
                if (selectedTileIds.has(tile.id)) selectedTileIds.clear(); else { selectedTileIds.clear(); selectedTileIds.add(tile.id); }
            }
            renderRack();
        }

        function handleBoardClick(r, c, existingTile, isTemp) {
            if (localGameState.currentPlayerIndex !== myPlayerIndex) return;
            if (localGameState.boardState[r*BOARD_SIZE+c]) return; 

            if (isTemp) {
                tempPlacedTiles = tempPlacedTiles.filter(t => !(t.r === r && t.c === c));
                renderGame();
                return;
            }

            if (!isSwapping && selectedTileIds.size === 1) {
                const tileId = [...selectedTileIds][0];
                const myRack = localGameState.players[myPlayerIndex].rack;
                const isAlreadyPlaced = tempPlacedTiles.some(t => t.tile.id === tileId);
                if (isAlreadyPlaced) return;

                const tileObj = myRack.find(t => t.id === tileId);
                if (tileObj) {
                    tempPlacedTiles.push({ r, c, tile: tileObj });
                    selectedTileIds.clear();
                    renderGame();
                }
            }
        }

        // --- Game Actions ---
        window.game = {
            async playTurn() {
                if (tempPlacedTiles.length === 0) return alert("ËØ∑ÂÖàÊîæÁâå");
                const error = validateMove(tempPlacedTiles, localGameState);
                if (error) return alert(error);
                const score = calculateScore(tempPlacedTiles, localGameState);
                await commitTurn({ type: 'play', placedTiles: tempPlacedTiles, score: score });
                tempPlacedTiles = [];
            },
            recallTiles() { tempPlacedTiles = []; renderGame(); },
            toggleSwapMode() {
                 if (tempPlacedTiles.length > 0) return alert("ËØ∑ÂÖàÊî∂ÂõûÁâå");
                 if (!isSwapping) {
                     isSwapping = true;
                     selectedTileIds.clear();
                     document.getElementById('btn-swap').innerText = "‚úÖ Á°ÆËÆ§";
                     document.getElementById('btn-swap').classList.add('active');
                 } else {
                     if (selectedTileIds.size > 0) {
                         const tilesToSwap = [...selectedTileIds];
                         commitTurn({ type: 'swap', tileIds: tilesToSwap });
                     }
                     isSwapping = false;
                     selectedTileIds.clear();
                     document.getElementById('btn-swap').innerText = "‚ôªÔ∏è Êç¢Áâå";
                     document.getElementById('btn-swap').classList.remove('active');
                 }
                 renderRack();
            },
            async passTurn() {
                if (confirm("Á°ÆÂÆöË∑≥ËøáÂõûÂêàÔºü(ËøûÁª≠3Ê¨°Ë∑≥ËøáÂ∞ÜÊ∑òÊ±∞)")) {
                    await commitTurn({ type: 'pass' });
                }
            },
            showTutorial() { document.getElementById('tutorial-modal').style.display = 'flex'; }
        };

        function generateTileBag() {
            let bag = []; let id = 0;
            for (let k in TILE_CONFIG) { for(let i=0; i<TILE_CONFIG[k]; i++) bag.push({ char: k, score: SCORES[k], id: 't'+(id++) }); }
            return bag.sort(() => Math.random() - 0.5);
        }

        function drawTilesForPlayer(currentRack, currentBag) {
            let nums = currentRack.filter(t => /^[0-9]$/.test(t.char)).length;
            let ops = currentRack.filter(t => !/^[0-9]$/.test(t.char)).length;
            let newRack = [...currentRack]; let newBag = [...currentBag];
            while (nums < 5) {
                const idx = newBag.findIndex(t => /^[0-9]$/.test(t.char));
                if (idx === -1) break;
                newRack.push(newBag.splice(idx, 1)[0]); nums++;
            }
            while (ops < 3) {
                const idx = newBag.findIndex(t => !/^[0-9]$/.test(t.char));
                if (idx === -1) break;
                newRack.push(newBag.splice(idx, 1)[0]); ops++;
            }
            return { rack: newRack, bag: newBag };
        }

        async function commitTurn(action) {
            const roomRef = doc(db, 'artifacts', APP_ID, 'public', 'data', 'rooms', currentRoomId);
            let updates = {};
            let me = localGameState.players[myPlayerIndex];
            let bag = [...localGameState.tileBag];
            let board = [...localGameState.boardState]; 
            
            if (action.type === 'play') {
                action.placedTiles.forEach(pt => { board[pt.r * BOARD_SIZE + pt.c] = pt.tile; });
                updates.boardState = board;
                const usedIds = new Set(action.placedTiles.map(pt => pt.tile.id));
                me.rack = me.rack.filter(t => !usedIds.has(t.id));
                me.score += action.score;
                me.misses = 0; 
                const res = drawTilesForPlayer(me.rack, bag);
                me.rack = res.rack; bag = res.bag;
            } else if (action.type === 'swap') {
                const swapIds = new Set(action.tileIds);
                const swappingTiles = me.rack.filter(t => swapIds.has(t.id));
                me.rack = me.rack.filter(t => !swapIds.has(t.id));
                bag.push(...swappingTiles);
                bag.sort(() => Math.random() - 0.5);
                const res = drawTilesForPlayer(me.rack, bag);
                me.rack = res.rack; bag = res.bag;
                me.misses += 1;
            } else if (action.type === 'pass') {
                me.misses += 1;
            }

            if (me.misses >= 3) { me.active = false; alert("‰Ω†Â∑≤ËøûÁª≠3Ê¨°Êú™ÂæóÂàÜÔºåË¢´Ê∑òÊ±∞ÔºÅ"); }
            const allPlayers = [...localGameState.players];
            allPlayers[myPlayerIndex] = me;
            updates.players = allPlayers;
            updates.tileBag = bag;

            let nextIdx = (localGameState.currentPlayerIndex + 1) % 4;
            let activeCount = allPlayers.filter(p => p.active).length;
            let loops = 0;
            if (activeCount <= 1 || (me.rack.length === 0 && bag.length === 0)) {
                updates.status = 'finished';
            } else {
                 while (!allPlayers[nextIdx].active && loops < 4) { nextIdx = (nextIdx + 1) % 4; loops++; }
                 updates.currentPlayerIndex = nextIdx;
            }

            await updateDoc(roomRef, updates);
            tempPlacedTiles = []; selectedTileIds.clear(); isSwapping = false;
        }

        function validateMove(placed, state) {
            const rows = placed.map(p => p.r); const cols = placed.map(p => p.c);
            const isRow = rows.every(r => r === rows[0]); const isCol = cols.every(c => c === cols[0]);
            if (!isRow && !isCol) return "ÂøÖÈ°ªÊéíÊàê‰∏ÄÁ∫ø";

            const isFirst = state.boardState.every(x => x === null);
            if (isFirst) {
                const hasCenter = placed.some(p => p.r===7 && p.c===7);
                if (!hasCenter) return "È¶ñÊâãÂøÖÈ°ªÁªèËøá‰∏≠ÂøÉ‚òÖ";
            } else {
                let connected = false;
                placed.forEach(p => {
                     const idx = p.r*BOARD_SIZE+p.c;
                     if ( (p.r>0 && state.boardState[idx-BOARD_SIZE]) || 
                          (p.r<14 && state.boardState[idx+BOARD_SIZE]) ||
                          (p.c>0 && state.boardState[idx-1]) ||
                          (p.c<14 && state.boardState[idx+1]) ) connected = true;
                });
                if (!connected) return "ÂøÖÈ°ª‰∏éÁé∞ÊúâÁâåÁõ∏Ëøû";
            }
            return null; 
        }

        function calculateScore(placed, state) {
            return placed.reduce((sum, p) => sum + p.tile.score, 0) * (placed.length > 5 ? 2 : 1);
        }
        
        function disableAllButtons(disabled) {
            document.querySelectorAll('.actions button').forEach(b => {
                if (b.id !== 'btn-help') b.disabled = disabled;
            });
        }

        // End Game UI Logic
        function endGameUI(finalState) {
            let msgHTML = `<div style="color:#e76f51; margin-bottom:10px;">ÊØîËµõÁªìÊùüÔºÅ</div>`;
            const players = [...finalState.players];
            players.sort((a, b) => b.score - a.score);
            let tableHTML = `<table class="endgame-table"><tr><th>ÂêçÊ¨°</th><th>Áé©ÂÆ∂</th><th>ÂæóÂàÜ</th></tr>`;
            players.forEach((p, index) => {
                const medal = index === 0 ? 'ü•á' : (index === 1 ? 'ü•à' : (index === 2 ? 'ü•â' : ''));
                tableHTML += `<tr><td>${medal} ${index + 1}</td><td>${p.name}</td><td><strong>${p.score}</strong></td></tr>`;
            });
            tableHTML += `</table>`;
            document.getElementById('modal-title').innerText = "üèÜ ÊúÄÁªàÊàòÊä•";
            document.getElementById('modal-msg').innerHTML = msgHTML + tableHTML;
            document.getElementById('modal').style.display = 'flex';
        }

        initSystem();
    </script>
</body>
</html>
