<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <!-- æ·»åŠ  viewport-fit=cover ä»¥æ›´å¥½é€‚é…å…¨é¢å±è®¾å¤‡ -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>G-MATH - æ•°å­¦æ‹¼å­—æ¸¸æˆ (Online)</title>
    <style>
        :root {
            /* åŸºç¡€é¢œè‰² */
            --board-bg: #f0f0f0;
            --tile-bg: #fdf5e6;
            --tile-color: #333;
            --dl-color: #a8e6cf;
            --tl-color: #3d84a8;
            --dw-color: #ffaaa5;
            --tw-color: #ff8b94;
            --accent: #4a4e69;
            --dark-bg: #22223b;
        }

        * { box-sizing: border-box; }

        /* é»˜è®¤ body æ ·å¼ (é€‚ç”¨äºç«–å±/æ™®é€šæƒ…å†µ) */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--dark-bg);
            color: white;
            margin: 0;
            padding: 0;
            /* ç«–å±é»˜è®¤å…è®¸æ»šåŠ¨ï¼Œé«˜åº¦è‡ªåŠ¨ */
            height: auto;
            min-height: 100vh;
            overflow-y: auto; 
            display: flex;
            flex-direction: column;
        }

        /* === é¡¶éƒ¨å¯¼èˆª === */
        header {
            height: 50px;
            background: #1a1a2e;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            flex-shrink: 0;
            z-index: 20;
            position: relative; /* ç¡®ä¿å±‚çº§ */
        }

        h1 {
            margin: 0;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        /* === ä¸»å¸ƒå±€å®¹å™¨ === */
        .main-wrapper {
            flex: 1;
            display: flex;
            padding: 10px;
            width: 100%;
        }

        /* === æ£‹ç›˜åŒºåŸŸ === */
        .board-area {
            flex-shrink: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #4a4e69;
            padding: 8px;
            border-radius: 8px;
            box-shadow: 5px 5px 20px rgba(0,0,0,0.4);
        }

        #game-board {
            display: grid;
            grid-template-columns: repeat(15, var(--cell-size));
            grid-template-rows: repeat(15, var(--cell-size));
            gap: 2px;
            background-color: #333;
            border: 2px solid #333;
        }

        .cell {
            width: var(--cell-size);
            height: var(--cell-size);
            background-color: var(--board-bg);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: calc(var(--cell-size) * 0.28);
            color: #333;
            font-weight: bold;
            position: relative;
            user-select: none;
            cursor: pointer;
        }

        /* ç‰¹æ®Šæ ¼å­æ ·å¼ */
        .cell.dl { background-color: var(--dl-color); color: #004d40; }
        .cell.tl { background-color: var(--tl-color); color: white; }
        .cell.dw { background-color: var(--dw-color); color: #880e4f; }
        .cell.tw { background-color: var(--tw-color); color: #880e4f; }
        .cell.center { background-color: var(--dw-color); font-size: calc(var(--cell-size) * 0.6); }

        /* ç‰Œæ ·å¼ */
        .tile {
            width: calc(var(--cell-size) - 4px);
            height: calc(var(--cell-size) - 4px);
            background-color: var(--tile-bg);
            border-radius: 4px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: calc(var(--cell-size) * 0.55);
            font-weight: bold;
            color: var(--tile-color);
            box-shadow: 2px 2px 4px rgba(0,0,0,0.2);
            cursor: grab;
            z-index: 10;
            position: relative;
            transition: transform 0.1s, border 0.1s, box-shadow 0.1s;
        }
        .tile span.points {
            position: absolute;
            bottom: 2px;
            right: 3px;
            font-size: calc(var(--cell-size) * 0.25);
            color: #666;
        }
        .tile.temp { border: 2px solid #4caf50; box-shadow: 0 0 5px #4caf50; }
        .tile.locked { cursor: default; background-color: #ddd; color: #555; }
        .tile.selected {
            transform: translateY(-8px) scale(1.1);
            border: 2px solid #ffd700;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.9);
            z-index: 20;
            background-color: #fffbf0;
        }
        .rack-swapping {
            background: rgba(233, 196, 106, 0.2) !important;
            border: 2px dashed #e9c46a !important;
        }

        /* === ä¾§è¾¹æ  === */
        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .panel {
            background: rgba(255,255,255,0.07);
            padding: 15px;
            border-radius: 12px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255,255,255,0.1);
        }

        #rack-container {
            background: rgba(0,0,0,0.3);
            padding: 15px;
            border-radius: 10px;
            min-height: calc(var(--cell-size) * 1.2 + 20px);
            display: flex;
            gap: 8px;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            border: 2px dashed rgba(255,255,255,0.1);
            transition: background 0.3s;
        }
        
        #rack-container .tile {
            transform: scale(1.1); 
            margin: 5px;
            cursor: pointer;
        }
        #rack-container .tile.selected {
            transform: scale(1.2) translateY(-5px);
        }

        /* æ’è¡Œæ¦œ */
        .score-board {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        .player-score {
            display: flex;
            justify-content: space-between;
            padding: 8px 10px;
            font-size: 1rem;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            border-radius: 4px;
        }
        .player-score.active { 
            background: linear-gradient(90deg, rgba(255,215,0,0.2) 0%, transparent 100%);
            color: #ffd700; 
            font-weight: bold;
            border-left: 4px solid #ffd700;
        }
        .player-score.eliminated {
            opacity: 0.5;
            background: rgba(0,0,0,0.3);
            color: #aaa;
            text-decoration: line-through;
        }

        /* æŒ‰é’®ç»„ */
        .actions { 
            display: grid; 
            grid-template-columns: 1fr 1fr 1fr;
            gap: 10px; 
        }
        button {
            padding: 12px 5px;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 5px;
        }
        button:active { transform: translateY(2px); box-shadow: 0 1px 2px rgba(0,0,0,0.2); }
        button:disabled { opacity: 0.5; cursor: not-allowed; filter: grayscale(100%); }
        
        .btn-play { background: #2a9d8f; color: white; grid-column: span 3; font-size: 1.1rem; padding: 15px;}
        .btn-swap { background: #e9c46a; color: #333; }
        .btn-swap.active { background: #ffca3a; box-shadow: inset 0 0 10px rgba(0,0,0,0.2); animation: pulse 2s infinite; }
        .btn-reset { background: #e76f51; color: white; }
        .btn-pass { background: #264653; color: white; }
        .btn-shuffle { background: #457b9d; color: white; grid-column: span 2; font-size: 0.8rem; opacity: 0.9;} 
        .btn-help { background: #607d8b; color: white; grid-column: span 1; font-size: 0.8rem; opacity: 0.9; }

        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.02); } 100% { transform: scale(1); } }

        #message-area {
            text-align: center;
            color: #ffd700;
            font-weight: bold;
            padding: 10px;
            background: rgba(0,0,0,0.4);
            border-radius: 6px;
            font-size: 1rem;
        }

        .legend {
            display: flex;
            justify-content: space-around;
            font-size: 0.75rem;
            padding: 10px;
        }
        .legend div { display: flex; align-items: center; gap: 5px; }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        .modal-content {
            background: white;
            color: #333;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            max-width: 600px;
            width: 90%;
            max-height: 85vh;
            overflow-y: auto;
            position: relative;
        }
        .tutorial-section { text-align: left; margin-bottom: 20px; padding: 10px; background: #f9f9f9; border-radius: 8px; }
        .tutorial-section h3 { color: #2a9d8f; border-bottom: 2px solid #eee; padding-bottom: 5px; margin-top: 0;}
        .tutorial-list { padding-left: 20px; margin: 10px 0; }
        .tutorial-list li { margin-bottom: 8px; line-height: 1.4; }
        .key-point { font-weight: bold; color: #e76f51; }
        .close-btn { position: absolute; top: 15px; right: 20px; font-size: 1.5rem; cursor: pointer; color: #999; }
        .endgame-table { width: 100%; border-collapse: collapse; margin: 20px 0; }
        .endgame-table th, .endgame-table td { padding: 10px; border-bottom: 1px solid #ddd; }
        .endgame-table th { background: #f0f0f0; color: #333; }
        .score-change.negative { color: #e76f51; }
        .score-change.positive { color: #2a9d8f; font-weight: bold; }

        /* === å“åº”å¼å¸ƒå±€ï¼šé’ˆå¯¹æ¨ªå± (Landscape) === */
        @media (orientation: landscape) {
            body {
                height: 100vh; /* å¼ºåˆ¶å…¨å±é«˜åº¦ */
                height: 100dvh; /* é€‚é…ç§»åŠ¨ç«¯åŠ¨æ€åœ°å€æ  */
                overflow: hidden; /* é”å®šæ»šåŠ¨ï¼Œç¡®ä¿å†…å®¹åœ¨å±å¹•å†… */
            }

            /* è®¡ç®—å•å…ƒæ ¼å¤§å°ï¼šé¢„ç•™é¡¶éƒ¨ Header(50px) å’Œ ä¸Šä¸‹ç¼“å†²(çº¦60px)ï¼Œä»¥åŠ dvh æ”¯æŒ */
            :root {
                --available-h: calc(100dvh - 100px); /* å‡å»æ›´å¤šç©ºé—´ä»¥é˜²åº•éƒ¨è¢«é®æŒ¡ */
                --cell-size: min(calc(var(--available-h) / 15), calc(55vw / 15));
                --sidebar-padding: 20px;
            }

            .main-wrapper {
                height: calc(100dvh - 50px);
                overflow: hidden;
                align-items: center;
                justify-content: flex-start;
                gap: 2vw;
                padding: 5px var(--sidebar-padding);
            }

            .board-area {
                padding: 4px;
            }

            /* ä¾§è¾¹æ é€‚é…ï¼šé«˜åº¦è·Ÿéšæ£‹ç›˜ï¼Œå†…éƒ¨ä½¿ç”¨ flex åˆ†é…ç©ºé—´ */
            .sidebar {
                flex: 1;
                /* é«˜åº¦ä¸æ£‹ç›˜å¯¹é½ï¼Œç¡®ä¿ä¸è¶…å‡ºä¸€å± */
                height: calc(15 * var(--cell-size) + 12px); 
                min-width: 280px;
                gap: 2vh; /* ä½¿ç”¨ç›¸å¯¹å•ä½é—´è· */
            }

            /* è®©ä¾§è¾¹æ å†…éƒ¨å…ƒç´ è‡ªé€‚åº”é«˜åº¦ */
            .panel {
                padding: 1.5vh; /* å‡å°‘å†…è¾¹è· */
            }
            
            /* å­—ä½“å¤§å°éšè§†å£é«˜åº¦ç¼©æ”¾ï¼Œé˜²æ­¢åœ¨å°æ¨ªå±è®¾å¤‡ä¸Šå¤ªå¤§ */
            .panel, button, .player-score {
                font-size: clamp(0.8rem, 2.2vh, 1rem); 
            }

            h4 { margin: 0 0 0.5vh 0; }

            #rack-container {
                min-height: calc(var(--cell-size) * 1.2 + 10px);
                padding: 5px;
            }

            /* æŒ‰é’®æ›´ç´§å‡‘ */
            button {
                padding: 1.2vh 5px;
            }

            /* éšè—å¤šä½™ç©ºç™½ */
            .score-board {
                overflow-y: auto; /* å¦‚æœç§¯åˆ†æ¦œå¤ªé•¿ï¼Œå…è®¸å†…éƒ¨æ»šåŠ¨ */
                flex-shrink: 1;   /* å…è®¸å‹ç¼© */
            }
        }

        /* === å“åº”å¼å¸ƒå±€ï¼šé’ˆå¯¹ç«–å± (Portrait) === */
        @media (orientation: portrait) {
            :root {
                --cell-size: calc((100vw - 20px) / 15);
            }

            .main-wrapper {
                flex-direction: column;
                justify-content: flex-start;
                padding: 10px;
                height: auto; /* å…è®¸æ’‘å¼€ */
                overflow: visible;
            }
            
            .sidebar {
                width: 100%;
                height: auto;
                flex: none;
                gap: 10px;
            }

            .board-area { margin-bottom: 10px; }
            .score-board { display: none; } /* ç§»åŠ¨ç«¯ç«–å±éšè—è¯¦ç»†ç§¯åˆ†æ¦œ */
            .mobile-score { display: inline-block !important; color: #ffd700; font-size: 0.9rem;}
            
            #rack-container .tile { transform: scale(1); }
            #rack-container .tile.selected { transform: scale(1.1) translateY(-5px); }
        }
        
        .mobile-score { display: none; }
        
        /* Online Lobby Styles */
        #lobby-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #1a1a2e;
            z-index: 200;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
        }
        .lobby-box {
            background: #22223b;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            border: 1px solid #4a4e69;
            width: 90%;
            max-width: 400px;
        }
        .lobby-input {
            padding: 12px;
            border-radius: 5px;
            border: none;
            margin: 15px auto; /* Changed to center */
            width: 80%;
            display: block; /* Force block to center */
            font-size: 1.2rem;
            text-align: center;
            letter-spacing: 2px;
        }
        .lobby-btn {
            background: #2a9d8f;
            color: white;
            padding: 12px 20px;
            border: none;
            border-radius: 5px;
            font-size: 1rem;
            cursor: pointer;
            margin: 15px auto; /* Changed to center */
            width: 80%;
            display: block; /* Force block to center */
        }
        .lobby-btn.secondary { background: #4a4e69; }
    </style>
</head>
<body>

    <header>
        <h1>G-MATH ğŸ§® <span class="mobile-score" id="mobile-score-display"></span></h1>
        <div style="font-size: 0.9rem; color: #ccc;">
            å‰©ä½™: <span id="tiles-left-header" style="font-weight:bold; color:white;">0</span>
        </div>
    </header>

    <div class="main-wrapper">
        <div class="board-area">
            <div id="game-board"></div>
        </div>

        <div class="sidebar">
            <div id="message-area">æ¬¢è¿æ¥åˆ° G-MATH!</div>

            <div class="panel score-board">
                <h4 style="border-bottom:1px solid rgba(255,255,255,0.2); padding-bottom:5px;">
                    ğŸ“Š ç©å®¶ç§¯åˆ†
                </h4>
                <div id="players-list"></div>
            </div>

            <div class="panel">
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;">
                    <div style="font-weight:bold; color:#ddd;">ğŸ–ï¸ ä½ çš„æ‰‹ç‰Œ:</div>
                    <div style="font-size:0.8em; color:#aaa;" id="rack-hint">(ç‚¹å‡»é€‰ä¸­ï¼Œå†ç‚¹æ£‹ç›˜)</div>
                </div>
                <div id="rack-container"></div>
            </div>

            <div class="actions">
                <button class="btn-play" id="btn-play" onclick="game.playTurn()">âœ… ç¡®è®¤å‡ºç‰Œ</button>
                
                <button class="btn-swap" id="btn-swap" onclick="game.toggleSwapMode()">â™»ï¸ æ¢ç‰Œ</button>
                <button class="btn-reset" id="btn-reset" onclick="game.recallTiles()">â†©ï¸ æ”¶å›</button>
                <button class="btn-pass" id="btn-pass" onclick="game.passTurn()">â­ï¸ è·³è¿‡</button>
                
                <button class="btn-shuffle" onclick="game.shuffleRack()">ğŸ”€ æ•´ç†</button>
                <button class="btn-help" onclick="game.showTutorial()">â“ è¯´æ˜</button>
            </div>
            
            <div class="panel legend">
                <div><span style="color:var(--dl-color)">â– </span> 2å€æ•°</div>
                <div><span style="color:var(--tl-color)">â– </span> 3å€æ•°</div>
                <div><span style="color:var(--dw-color)">â– </span> 2å€å¼</div>
                <div><span style="color:var(--tw-color)">â– </span> 3å€å¼</div>
            </div>
        </div>
    </div>

    <!-- Modal: Game Over -->
    <div id="modal" class="modal">
        <div class="modal-content" style="max-width: 500px;">
            <h2 id="modal-title" style="margin-top:0">ğŸ† æ¸¸æˆç»“æŸ</h2>
            <div id="modal-msg"></div>
            <button onclick="location.reload()" style="background:#2a9d8f; color:white; padding:15px 30px; font-size:1.1rem; margin-top: 20px;">å†ç©ä¸€æ¬¡</button>
        </div>
    </div>

    <!-- Modal: Tutorial -->
    <div id="tutorial-modal" class="modal" style="display: none;">
        <div class="modal-content" style="text-align:left; max-width: 650px;">
            <span class="close-btn" onclick="document.getElementById('tutorial-modal').style.display='none'">&times;</span>
            <h2 style="text-align:center; margin-top:0; color:#4a4e69;">ğŸ“– G-MATH æ¸¸æˆæŒ‡å—</h2>
            
            <div class="tutorial-section">
                <h3>ğŸ¯ æ¸¸æˆç›®æ ‡</h3>
                <p>åˆ©ç”¨æ‰‹ä¸­çš„æ•°å­—å’Œç¬¦å·ç‰Œï¼Œåœ¨æ£‹ç›˜ä¸Šæ‹¼å‡º<strong>æ­£ç¡®çš„æ•°å­¦ç­‰å¼</strong>ï¼Œäº‰å–è·å¾—æœ€é«˜åˆ†ï¼</p>
            </div>

            <div class="tutorial-section">
                <h3>ğŸ•¹ï¸ ç©æ³•æµç¨‹</h3>
                <ul class="tutorial-list">
                    <li><strong>ç¬¬ä¸€æ­¥ï¼š</strong>é¦–ä½ç©å®¶å‡ºç‰Œå¿…é¡»è¦†ç›–æ£‹ç›˜ä¸­å¿ƒçš„ <span style="color:#ffaaa5; font-weight:bold;">â˜…</span> æ˜Ÿå·ã€‚</li>
                    <li><strong>è¿æ¥ï¼š</strong>ä¹‹åçš„å‡ºç‰Œå¿…é¡»æ¨ªå‘æˆ–çºµå‘æ’åˆ—ï¼Œå¹¶ä¸æ£‹ç›˜ä¸Šå·²æœ‰çš„ç‰Œç›¸è¿ã€‚</li>
                    <li><strong>ç­‰å¼ï¼š</strong>å¿…é¡»å½¢æˆæ•°å­¦ä¸Šæˆç«‹çš„ç­‰å¼ï¼ˆåŒ…å« <code>=</code>ï¼‰ã€‚<br>
                        <small style="color:#555; background:#eee; padding:2px 5px; border-radius:4px;">âœ” ä¾‹å­ï¼š<code>2+3=5</code> æˆ–è¿ç­‰å¼ <code>32Ã·8=7-3=4</code></small>
                    </li>
                </ul>
            </div>

            <div class="tutorial-section">
                <h3>ğŸ–ï¸ æ“ä½œæŒ‡å— (æ”¯æŒè§¦å±)</h3>
                <ul class="tutorial-list">
                    <li><strong>å‡ºç‰Œï¼š</strong>ç‚¹å‡»æ‰‹ç‰Œé€‰ä¸­ï¼ˆå˜äº®ï¼‰ -> ç‚¹å‡»æ£‹ç›˜æ ¼å­æ”¾ç½®ã€‚</li>
                    <li><strong>è°ƒæ•´ï¼š</strong>ç‚¹å‡»æ£‹ç›˜ä¸Šåˆšæ”¾ä¸‹çš„ç‰Œï¼Œå¯ä»¥å°†å…¶æ”¶å›æ‰‹ç‰Œã€‚</li>
                    <li><strong>æ¢ç‰Œï¼š</strong>æ‰‹ç‰Œä¸å¥½ï¼Ÿç‚¹å‡»â€œâ™»ï¸ æ¢ç‰Œâ€è¿›å…¥æ¢ç‰Œæ¨¡å¼ã€‚<br>
                        <span style="color:#e76f51; font-size:0.9em;">(æ³¨æ„ï¼šæ¢ç‰Œè§†ä¸ºæœªå¾—åˆ†æ“ä½œï¼Œä¼šè·³è¿‡æœ¬å›åˆ)</span>
                    </li>
                </ul>
            </div>

            <div class="tutorial-section">
                <h3>ğŸ† ç«æŠ€è§„åˆ™</h3>
                <ul class="tutorial-list">
                    <li><strong>æ·˜æ±°æœºåˆ¶ï¼š</strong>åŒä¸€ç©å®¶è¿ç»­ <span class="key-point">3æ¬¡</span> æœªå¾—åˆ†ï¼ˆè·³è¿‡æˆ–æ¢ç‰Œï¼‰ï¼Œå°†è¢«<span class="key-point">ç›´æ¥æ·˜æ±°</span>å‡ºå±€ï¼</li>
                    <li><strong>æ¸¸æˆç»“æŸï¼š</strong>å½“ç‰Œåº“ç©ºäº†ä¸”æœ‰äººå‡ºå®Œç‰Œï¼Œæˆ–è€…åœºä¸Šåªå‰©1äººæ—¶ç»“æŸã€‚</li>
                    <li><strong>èƒœè´Ÿï¼š</strong>æœ€ç»ˆç§¯åˆ†æœ€é«˜è€…è·èƒœã€‚</li>
                </ul>
            </div>

            <div style="background:#e3f2fd; padding:12px; border-radius:8px; margin-top:15px; text-align:center; border:1px solid #bbdefb; color:#0d47a1;">
                ğŸ–¥ï¸ <strong>ä½“éªŒå‡çº§ï¼š</strong> å»ºè®®æŒ‰é”®ç›˜ <strong>F11</strong> è¿›å…¥å…¨å±æ¨¡å¼ï¼Œæ“ä½œæ›´é¡ºç•…ï¼
            </div>

            <div style="text-align:center; margin-top:20px;">
                <button onclick="document.getElementById('tutorial-modal').style.display='none'" style="background:#2a9d8f; color:white; padding:12px 40px; font-size:1.1rem; border:none; border-radius:8px; cursor:pointer; font-weight:bold; box-shadow: 0 4px 6px rgba(0,0,0,0.2);">å¼€å§‹æŒ‘æˆ˜ï¼</button>
            </div>
        </div>
    </div>

<!-- Online Lobby Overlay -->
<div id="lobby-overlay">
    <div class="lobby-box">
        <h2>G-MATH è”æœºå¤§å…</h2>
        <p>è¯·é€‰æ‹©æ¨¡å¼</p>
        <div id="lobby-buttons">
            <button class="lobby-btn" onclick="createRoom()">åˆ›å»ºæˆ¿é—´</button>
            <p style="margin:10px; color:#aaa;">- æˆ– -</p>
            <input type="number" id="room-input" class="lobby-input" placeholder="è¾“å…¥6ä½æˆ¿é—´å·">
            <button class="lobby-btn secondary" onclick="joinRoom()">åŠ å…¥æˆ¿é—´</button>
        </div>
        <div id="lobby-status" style="margin-top:20px; color:#ffd700; min-height: 20px;"></div>
    </div>
</div>

<script type="module">
/**
 * G-MATH æ¸¸æˆé€»è¾‘ (JavaScript)
 */
// 1. é…ç½®ä¸æ•°æ®
const BOARD_SIZE = 15;
const RACK_SIZE = 8; 

// ç‰Œåº“åˆ†å¸ƒ: å¢åŠ ç­‰äºå·æ•°é‡ (æ€»æ•° 108 å¼ )
const TILE_DISTRIBUTION = {
    // --- å·ç ç‰Œ (å…± 60 å¼ ) ---
    '0': { count: 6, score: 1 },
    '1': { count: 6, score: 1 },
    '2': { count: 6, score: 2 },
    '3': { count: 6, score: 2 },
    '4': { count: 6, score: 2 },
    '5': { count: 6, score: 3 },
    '6': { count: 6, score: 3 },
    '7': { count: 6, score: 4 },
    '8': { count: 6, score: 4 },
    '9': { count: 6, score: 4 },
    
    // --- è¿ç®—ç‰Œ (å…± 48 å¼ ) ---
    '+': { count: 7, score: 2 },
    '-': { count: 7, score: 2 },
    'Ã—': { count: 7, score: 4 }, 
    'Ã·': { count: 7, score: 4 },
    '=': { count: 20, score: 1 } // å¤§å¹…å¢åŠ ï¼Œé˜²æ­¢å¡æ‰‹
};

const SPECIAL_CELLS = {
    'TW': ['0,0', '0,7', '0,14', '7,0', '7,14', '14,0', '14,7', '14,14'],
    'DW': ['1,1', '2,2', '3,3', '4,4', '10,10', '11,11', '12,12', '13,13', '1,13', '2,12', '3,11', '4,10', '10,4', '11,3', '12,2', '13,1'],
    'TL': ['1,5', '1,9', '5,1', '5,5', '5,9', '5,13', '9,1', '9,5', '9,9', '9,13', '13,5', '13,9'],
    'DL': ['0,3', '0,11', '2,6', '2,8', '3,0', '3,7', '3,14', '6,2', '6,6', '6,8', '6,12', '7,3', '7,11', '8,2', '8,6', '8,8', '8,12', '11,0', '11,7', '11,14', '12,6', '12,8', '14,3', '14,11']
};

class Tile {
    constructor(char, id) {
        this.char = char;
        this.score = TILE_DISTRIBUTION[char].score;
        this.id = id; 
        this.element = this.createElement();
    }

    createElement() {
        const el = document.createElement('div');
        el.className = 'tile';
        el.draggable = true;
        el.id = `tile-${this.id}`;
        el.dataset.tileId = this.id;
        el.innerHTML = `${this.char}<span class="points">${this.score}</span>`;
        el.addEventListener('dragstart', (e) => {
            e.dataTransfer.setData('text/plain', this.id);
            e.dataTransfer.effectAllowed = "move";
            game.draggedTileId = this.id;
            game.selectTile(this.id, true); 
        });
        return el;
    }
}

class Game {
    constructor() {
        this.players = [
            { name: "ç©å®¶ 1", score: 0, rack: [], misses: 0, active: true },
            { name: "ç©å®¶ 2", score: 0, rack: [], misses: 0, active: true },
            { name: "ç©å®¶ 3", score: 0, rack: [], misses: 0, active: true },
            { name: "ç©å®¶ 4", score: 0, rack: [], misses: 0, active: true }
        ];
        this.currentPlayerIndex = 0;
        this.numberBag = [];
        this.operatorBag = []; 
        this.boardState = Array(BOARD_SIZE).fill(null).map(() => Array(BOARD_SIZE).fill(null)); 
        this.isFirstTurn = true;
        this.tempPlacedTiles = []; 
        this.selectedTileIds = new Set(); 
        this.isSwapping = false; 
        this.draggedTileId = null;
        this.consecutivePasses = 0;
        this.init();
    }

    init() {
        this.generateTileBag();
        this.renderBoard();
        this.shuffleBag();
        this.players.forEach(p => this.drawTiles(p));
        this.updateUI();
        // this.showMessage("ğŸ‘‰ ç©å®¶ 1 è¯·å‡ºç‰Œ"); // Initial msg moved to updateUI or connection logic
    }

    showTutorial() { document.getElementById('tutorial-modal').style.display = 'flex'; }

    generateTileBag() {
        this.numberBag = [];
        this.operatorBag = [];
        let idCounter = 0;
        for (let char in TILE_DISTRIBUTION) {
            const count = TILE_DISTRIBUTION[char].count;
            const isNumber = /^[0-9]$/.test(char);
            for (let i = 0; i < count; i++) {
                const tile = new Tile(char, idCounter++);
                if (isNumber) this.numberBag.push(tile);
                else this.operatorBag.push(tile);
            }
        }
    }

    shuffleBag() {
        const shuffle = (arr) => {
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
        };
        shuffle(this.numberBag);
        shuffle(this.operatorBag);
    }

    drawTiles(player) {
        let currentNums = player.rack.filter(t => /^[0-9]$/.test(t.char)).length;
        let currentOps = player.rack.filter(t => !/^[0-9]$/.test(t.char)).length;
        const MAX_NUMS = 5;
        const MAX_OPS = 3;
        let shortageMsg = "";

        while (currentNums < MAX_NUMS && this.numberBag.length > 0) {
            player.rack.push(this.numberBag.pop());
            currentNums++;
        }
        while (currentOps < MAX_OPS && this.operatorBag.length > 0) {
            player.rack.push(this.operatorBag.pop());
            currentOps++;
        }
        
        if (currentNums < MAX_NUMS && this.numberBag.length === 0) shortageMsg = "æ•°å­—ç‰Œè€—å°½";
        if (currentOps < MAX_OPS && this.operatorBag.length === 0) {
            shortageMsg = shortageMsg ? "ç‰Œåº“è€—å°½" : "è¿ç®—ç‰Œè€—å°½";
        }
        return shortageMsg;
    }

    renderBoard() {
        const boardEl = document.getElementById('game-board');
        boardEl.innerHTML = '';
        for (let r = 0; r < BOARD_SIZE; r++) {
            for (let c = 0; c < BOARD_SIZE; c++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.dataset.r = r;
                cell.dataset.c = c;
                const key = `${r},${c}`;
                if (r===7 && c===7) { cell.classList.add('center'); cell.innerHTML='â˜…'; }
                else if (SPECIAL_CELLS.TW.includes(key)) { cell.classList.add('tw'); cell.innerText='TW'; }
                else if (SPECIAL_CELLS.DW.includes(key)) { cell.classList.add('dw'); cell.innerText='DW'; }
                else if (SPECIAL_CELLS.TL.includes(key)) { cell.classList.add('tl'); cell.innerText='TL'; }
                else if (SPECIAL_CELLS.DL.includes(key)) { cell.classList.add('dl'); cell.innerText='DL'; }

                cell.onclick = () => this.handleBoardClick(r, c);
                cell.addEventListener('dragover', (e) => e.preventDefault());
                cell.addEventListener('drop', (e) => this.handleDropOnBoard(e, r, c));
                boardEl.appendChild(cell);
            }
        }
    }

    renderRack() {
        const rackContainer = document.getElementById('rack-container');
        rackContainer.innerHTML = '';
        const player = this.players[this.currentPlayerIndex];
        if (this.isSwapping) rackContainer.classList.add('rack-swapping');
        else rackContainer.classList.remove('rack-swapping');

        player.rack.forEach(tile => {
            const tileEl = tile.element;
            tileEl.classList.remove('temp', 'locked');
            if (this.selectedTileIds.has(tile.id)) tileEl.classList.add('selected');
            else tileEl.classList.remove('selected');

            tileEl.onclick = (e) => {
                e.stopPropagation();
                this.handleRackTileClick(tile.id);
            };
            rackContainer.appendChild(tileEl);
        });
    }

    handleRackTileClick(tileId) {
        if (this.isSwapping) {
            if (this.selectedTileIds.has(tileId)) this.selectedTileIds.delete(tileId);
            else this.selectedTileIds.add(tileId);
        } else {
            if (this.selectedTileIds.has(tileId)) {
                this.selectedTileIds.clear();
            } else {
                this.selectedTileIds.clear();
                this.selectedTileIds.add(tileId);
            }
        }
        this.renderRack();
    }

    handleBoardClick(r, c) {
        if (this.boardState[r][c] && !this.isTemp(r, c)) return;
        if (this.isTemp(r, c)) {
            const tile = this.boardState[r][c];
            this.boardState[r][c] = null;
            const tempIdx = this.tempPlacedTiles.findIndex(t => t.r === r && t.c === c);
            if (tempIdx > -1) this.tempPlacedTiles.splice(tempIdx, 1);
            this.updateCellUI(r, c);
            this.players[this.currentPlayerIndex].rack.push(tile);
            this.selectedTileIds.clear();
            this.selectedTileIds.add(tile.id);
            this.renderRack();
            this.showMessage("å·²æ”¶å›ç‰Œï¼Œç‚¹å‡»ç©ºæ ¼æ”¾ç½®");
            return;
        }
        if (this.selectedTileIds.size === 1 && !this.isSwapping) {
            const tileId = Array.from(this.selectedTileIds)[0];
            const player = this.players[this.currentPlayerIndex];
            const tileIndex = player.rack.findIndex(t => t.id == tileId);
            if (tileIndex > -1) {
                const tile = player.rack[tileIndex];
                this.placeTileTemp(tile, r, c);
                player.rack.splice(tileIndex, 1);
                this.selectedTileIds.clear();
                this.renderRack();
            }
        }
    }

    selectTile(tileId, forceExclusive = true) {
        if (forceExclusive) this.selectedTileIds.clear();
        this.selectedTileIds.add(tileId);
        this.renderRack();
    }

    handleDropOnBoard(e, r, c) {
        e.preventDefault();
        if (this.boardState[r][c] !== null) return; 
        const player = this.players[this.currentPlayerIndex];
        const tileIndex = player.rack.findIndex(t => t.id == this.draggedTileId);
        if (tileIndex > -1) {
            const tile = player.rack[tileIndex];
            this.placeTileTemp(tile, r, c);
            player.rack.splice(tileIndex, 1);
        } else {
            const existingTempIndex = this.tempPlacedTiles.findIndex(t => t.tile.id == this.draggedTileId);
            if (existingTempIndex > -1) {
                const oldPos = this.tempPlacedTiles[existingTempIndex];
                this.boardState[oldPos.r][oldPos.c] = null;
                this.updateCellUI(oldPos.r, oldPos.c);
                this.tempPlacedTiles.splice(existingTempIndex, 1);
                this.placeTileTemp(oldPos.tile, r, c);
            }
        }
        this.selectedTileIds.clear();
        this.renderRack();
    }

    placeTileTemp(tile, r, c) {
        this.boardState[r][c] = tile;
        this.tempPlacedTiles.push({r, c, tile});
        this.updateCellUI(r, c, true);
    }

    updateCellUI(r, c, isTemp = false) {
        const index = r * BOARD_SIZE + c;
        const cell = document.getElementById('game-board').children[index];
        const tile = this.boardState[r][c];
        if (!tile) {
            cell.innerHTML = '';
            const key = `${r},${c}`;
            if (r===7&&c===7) cell.innerHTML='â˜…';
            else if (SPECIAL_CELLS.TW.includes(key)) cell.innerText='TW';
            else if (SPECIAL_CELLS.DW.includes(key)) cell.innerText='DW';
            else if (SPECIAL_CELLS.TL.includes(key)) cell.innerText='TL';
            else if (SPECIAL_CELLS.DL.includes(key)) cell.innerText='DL';
            return;
        }
        cell.innerHTML = ''; 
        const tileEl = tile.element;
        tileEl.classList.remove('selected');
        tileEl.onclick = null;
        if (isTemp) tileEl.classList.add('temp');
        else tileEl.classList.add('locked');
        tileEl.draggable = isTemp; 
        cell.appendChild(tileEl);
    }

    recallTiles() {
        const player = this.players[this.currentPlayerIndex];
        this.tempPlacedTiles.forEach(item => {
            this.boardState[item.r][item.c] = null;
            this.updateCellUI(item.r, item.c);
            player.rack.push(item.tile);
        });
        this.tempPlacedTiles = [];
        this.selectedTileIds.clear();
        this.renderRack();
    }

    passTurn() {
        if (this.isSwapping) this.toggleSwapMode(); 
        this.recallTiles();
        const player = this.players[this.currentPlayerIndex];
        player.misses++;
        this.consecutivePasses++;
        if (this.consecutivePasses >= 4) {
            this.endGame(true);
            return;
        }
        if (this.checkElimination(player)) return;
        this.nextTurn(false); 
    }

    toggleSwapMode() {
        if (this.tempPlacedTiles.length > 0) {
            this.showMessage("âŒ è¯·å…ˆæ”¶å›æ£‹ç›˜ä¸Šçš„ç‰Œ", true);
            return;
        }
        if (!this.isSwapping) {
            this.isSwapping = true;
            this.selectedTileIds.clear();
            document.getElementById('btn-swap').innerText = "âœ… ç¡®è®¤äº¤æ¢";
            document.getElementById('btn-swap').classList.add('active');
            document.getElementById('rack-hint').innerText = "(å¤šé€‰æ¨¡å¼ï¼šè¯·é€‰æ‹©è¦ä¸¢å¼ƒçš„ç‰Œ)";
            this.showMessage("è¯·é€‰æ‹©è¦äº¤æ¢çš„ç‰Œï¼Œå†æ¬¡ç‚¹å‡»æŒ‰é’®ç¡®è®¤");
            this.toggleButtons(false);
        } else {
            this.executeSwap();
        }
        this.renderRack();
    }

    executeSwap() {
        if (this.selectedTileIds.size === 0) {
            this.exitSwapMode();
            this.showMessage("æœªé€‰æ‹©ç‰Œï¼Œå·²å–æ¶ˆæ¢ç‰Œ");
            return;
        }
        if (this.numberBag.length === 0 && this.operatorBag.length === 0) {
            this.exitSwapMode();
            this.showMessage("âŒ ç‰Œåº“ç©ºäº†ï¼Œæ— æ³•æ¢ç‰Œ", true);
            return;
        }
        const player = this.players[this.currentPlayerIndex];
        const newRack = [];
        const tilesToSwap = [];
        player.rack.forEach(tile => {
            if (this.selectedTileIds.has(tile.id)) tilesToSwap.push(tile);
            else newRack.push(tile);
        });
        tilesToSwap.forEach(tile => {
            tile.element.classList.remove('selected');
            if (/^[0-9]$/.test(tile.char)) this.numberBag.push(tile);
            else this.operatorBag.push(tile);
        });
        player.rack = newRack;
        this.shuffleBag();
        this.drawTiles(player);
        const count = tilesToSwap.length;
        this.exitSwapMode();
        this.showMessage(`â™»ï¸ æˆåŠŸäº¤æ¢ ${count} å¼ ç‰Œ`);
        player.misses++;
        this.consecutivePasses = 0; 
        if (this.checkElimination(player)) return;
        this.nextTurn(true);
    }

    checkElimination(player) {
        if (player.misses >= 3) {
            player.active = false; 
            this.showMessage(`ğŸš« ${player.name} è¿ç»­3æ¬¡æœªå¾—åˆ†ï¼Œå·²é€€å‡ºæ¯”èµ›ï¼`, true);
            const activePlayers = this.players.filter(p => p.active);
            if (activePlayers.length <= 1) {
                setTimeout(() => this.endGame(true), 1500); 
            } else {
                setTimeout(() => this.nextTurn(false), 1500);
            }
            return true; 
        }
        return false; 
    }

    exitSwapMode() {
        this.isSwapping = false;
        this.selectedTileIds.clear();
        document.getElementById('btn-swap').innerText = "â™»ï¸ æ¢ç‰Œ";
        document.getElementById('btn-swap').classList.remove('active');
        document.getElementById('rack-hint').innerText = "(ç‚¹å‡»é€‰ä¸­ï¼Œå†æ¬¡ç‚¹å‡»æ£‹ç›˜æ”¾ç½®)";
        this.toggleButtons(true);
        this.renderRack();
    }

    toggleButtons(enable) {
        const ids = ['btn-play', 'btn-reset', 'btn-pass'];
        ids.forEach(id => {
            document.getElementById(id).disabled = !enable;
        });
    }

    shuffleRack() {
        const p = this.players[this.currentPlayerIndex];
        for (let i = p.rack.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [p.rack[i], p.rack[j]] = [p.rack[j], p.rack[i]];
        }
        this.renderRack();
    }

    playTurn() {
        if (this.isSwapping) return; 
        if (this.tempPlacedTiles.length === 0) {
            this.showMessage("âš ï¸ è¯·å…ˆåœ¨æ£‹ç›˜ä¸Šæ”¾ç½®ç‰Œ", true);
            return;
        }
        const rows = this.tempPlacedTiles.map(t => t.r);
        const cols = this.tempPlacedTiles.map(t => t.c);
        const isRow = rows.every(r => r === rows[0]);
        const isCol = cols.every(c => c === cols[0]);
        if (!isRow && !isCol) {
            this.showMessage("âš ï¸ å¿…é¡»æ’åœ¨åŒä¸€è¡Œæˆ–åŒä¸€åˆ—", true);
            return;
        }
        this.tempPlacedTiles.sort((a, b) => isRow ? a.c - b.c : a.r - b.r);
        let lineTiles = []; 
        if (isRow) lineTiles = this.getContiguousLine(rows[0], this.tempPlacedTiles[0].c, 'row');
        else lineTiles = this.getContiguousLine(this.tempPlacedTiles[0].r, cols[0], 'col');
        if (this.isFirstTurn) {
            const usesCenter = lineTiles.some(t => t.r === 7 && t.c === 7);
            if (!usesCenter) { this.showMessage("âš ï¸ å¿…é¡»ç»è¿‡ä¸­å¿ƒæ˜Ÿå·(â˜…)", true); return; }
            if (lineTiles.length < 3) { this.showMessage("âš ï¸ ç¬¬ä¸€æ­¥è‡³å°‘éœ€è¦3å¼ ç‰Œ", true); return; }
        } else {
            const isConnected = lineTiles.some(t => !this.tempPlacedTiles.includes(t)); 
            let adjacentContact = false;
            if (!isConnected) {
                for (let t of this.tempPlacedTiles) {
                    if (this.hasNeighbor(t.r, t.c)) { adjacentContact = true; break; }
                }
            }
            if (!isConnected && !adjacentContact) { this.showMessage("âš ï¸ å¿…é¡»ä¸ç°æœ‰ç‰Œç›¸è¿", true); return; }
        }
        if (!this.isValidEquation(lineTiles)) {
            this.showMessage("âŒ æ— æ•ˆç­‰å¼: " + this.tilesToString(lineTiles), true);
            return;
        }
        let totalScore = this.calculateScore(lineTiles, isRow ? 'row' : 'col');
        for (let temp of this.tempPlacedTiles) {
            let crossLine = [];
            if (isRow) crossLine = this.getContiguousLine(temp.r, temp.c, 'col');
            else crossLine = this.getContiguousLine(temp.r, temp.c, 'row');
            if (crossLine.length > 1) {
                if (!this.isValidEquation(crossLine)) {
                    this.showMessage("âŒ å‚ç›´æ–¹å‘ç­‰å¼æ— æ•ˆ", true);
                    return;
                }
                totalScore += this.calculateScore(crossLine, isRow ? 'col' : 'row');
            }
        }
        this.confirmMove(totalScore);
    }

    hasNeighbor(r, c) {
        const dirs = [[0,1], [0,-1], [1,0], [-1,0]];
        for (let d of dirs) {
            const nr = r + d[0], nc = c + d[1];
            if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE) {
                if (this.boardState[nr][nc] && !this.isTemp(nr, nc)) return true;
            }
        }
        return false;
    }

    isTemp(r, c) { return this.tempPlacedTiles.some(t => t.r === r && t.c === c); }

    getContiguousLine(startR, startC, dir) {
        let line = [];
        let currR = startR, currC = startC;
        if (dir === 'row') {
            while (currC > 0 && this.boardState[currR][currC-1]) currC--;
            while (currC < BOARD_SIZE && this.boardState[currR][currC]) {
                line.push({r: currR, c: currC, tile: this.boardState[currR][currC]});
                currC++;
            }
        } else {
            while (currR > 0 && this.boardState[currR-1][currC]) currR--;
            while (currR < BOARD_SIZE && this.boardState[currR][currC]) {
                line.push({r: currR, c: currC, tile: this.boardState[currR][currC]});
                currR++;
            }
        }
        return line;
    }

    isValidEquation(lineObjects) {
        const str = this.tilesToString(lineObjects);
        if (!str.includes('=')) return false;
        const parts = str.split('=');
        if (parts.some(p => p === '')) return false;
        let targetValue = null;
        try {
            const firstPart = parts[0].replace(/Ã—/g, '*').replace(/Ã·/g, '/');
            if (/[^0-9+\-Ã—Ã·]/.test(parts[0])) return false; 
            if (/\/0/.test(firstPart)) return false; 
            targetValue = new Function(`return ${firstPart}`)();
            for (let i = 1; i < parts.length; i++) {
                const currentPartStr = parts[i].replace(/Ã—/g, '*').replace(/Ã·/g, '/');
                if (/[^0-9+\-Ã—Ã·]/.test(parts[i])) return false;
                if (/\/0/.test(currentPartStr)) return false;
                const currentValue = new Function(`return ${currentPartStr}`)();
                if (Math.abs(currentValue - targetValue) > 0.0001) return false; 
            }
            return true;
        } catch (e) { return false; }
    }

    tilesToString(lineObjects) { return lineObjects.map(obj => obj.tile.char).join(''); }

    calculateScore(lineObjects, dir) {
        let score = 0;
        let wordMultiplier = 1;
        lineObjects.forEach(obj => {
            let tileScore = obj.tile.score;
            if (this.isTemp(obj.r, obj.c)) {
                const key = `${obj.r},${obj.c}`;
                if (SPECIAL_CELLS.DL.includes(key)) tileScore *= 2;
                if (SPECIAL_CELLS.TL.includes(key)) tileScore *= 3;
                if (SPECIAL_CELLS.DW.includes(key) || (obj.r===7 && obj.c===7 && this.isFirstTurn)) wordMultiplier *= 2;
                if (SPECIAL_CELLS.TW.includes(key)) wordMultiplier *= 3;
            }
            score += tileScore;
        });
        return score * wordMultiplier;
    }

    confirmMove(points) {
        const player = this.players[this.currentPlayerIndex];
        player.score += points;
        player.misses = 0;
        this.consecutivePasses = 0; 
        this.showMessage(`ğŸ‰ æœ‰æ•ˆï¼å¾—åˆ†: ${points}`);
        this.tempPlacedTiles.forEach(t => {
            const el = t.tile.element;
            el.classList.remove('temp');
            el.classList.add('locked');
            el.draggable = false;
            this.updateCellUI(t.r, t.c);
        });
        this.tempPlacedTiles = [];
        this.isFirstTurn = false;
        this.selectedTileIds.clear();
        this.nextTurn(true);
    }

    nextTurn(isValidMove = false) {
        const player = this.players[this.currentPlayerIndex];
        let warning = "";
        if (player.active) {
            warning = this.drawTiles(player);
        }
        const bagsEmpty = this.numberBag.length === 0 && this.operatorBag.length === 0;
        if (player.rack.length === 0 && bagsEmpty) {
            this.endGame(false, player);
            return;
        }
        let loops = 0;
        do {
            this.currentPlayerIndex = (this.currentPlayerIndex + 1) % 4;
            loops++;
        } while (!this.players[this.currentPlayerIndex].active && loops < 4);
        if (loops >= 4) {
            this.endGame(true);
            return;
        }
        this.updateUI();
        let msg = `ğŸ‘‰ è½®åˆ° ${this.players[this.currentPlayerIndex].name}`;
        if (warning && player.rack.length < RACK_SIZE) {
             msg += ` (${warning}ï¼Œæ— æ³•è¡¥é½)`;
        }
        this.showMessage(msg);
    }

    endGame(isForced = false, finishingPlayer = null) {
        let msgHTML = "";
        if (isForced) {
            msgHTML += `<div style="color:#e76f51; margin-bottom:10px;">ğŸš« è¿ç»­4æ¬¡è·³è¿‡æˆ–ä»…å‰©ä¸€äººï¼Œæ¯”èµ›ç»“æŸï¼</div>`;
        } else if (finishingPlayer) {
            msgHTML += `<div style="color:#2a9d8f; margin-bottom:10px;">ğŸ‰ ${finishingPlayer.name} å‡ºå®Œäº†æ‰€æœ‰ç‰Œï¼</div>`;
        }
        this.players.sort((a, b) => b.score - a.score);
        const winner = this.players[0];
        let tableHTML = `<table class="endgame-table">
            <tr><th>åæ¬¡</th><th>ç©å®¶</th><th>çŠ¶æ€</th><th>æœ€ç»ˆå¾—åˆ†</th></tr>`;
        this.players.forEach((p, index) => {
            const status = p.active ? 'å®Œèµ›' : 'æ·˜æ±°';
            const medal = index === 0 ? 'ğŸ¥‡' : (index === 1 ? 'ğŸ¥ˆ' : (index === 2 ? 'ğŸ¥‰' : ''));
            tableHTML += `<tr>
                <td>${medal} ${index + 1}</td>
                <td>${p.name}</td>
                <td style="color:${p.active ? '#2a9d8f' : '#e76f51'}">${status}</td>
                <td><strong>${p.score}</strong></td>
            </tr>`;
        });
        tableHTML += `</table>`;
        document.getElementById('modal-title').innerText = "ğŸ† æœ€ç»ˆæˆ˜æŠ¥";
        document.getElementById('modal-msg').innerHTML = msgHTML + tableHTML;
        document.getElementById('modal').style.display = 'flex';
    }

    updateUI() {
        const list = document.getElementById('players-list');
        list.innerHTML = '';
        this.players.forEach((p, i) => {
            const div = document.createElement('div');
            div.className = `player-score ${i === this.currentPlayerIndex ? 'active' : ''} ${!p.active ? 'eliminated' : ''}`;
            div.innerHTML = `<span>${p.name}</span> <span>${p.score}</span>`;
            list.appendChild(div);
        });
        const cp = this.players[this.currentPlayerIndex];
        document.getElementById('mobile-score-display').innerText = `${cp.name}: ${cp.score}åˆ†`;
        document.getElementById('tiles-left-header').innerText = `${this.numberBag.length + this.operatorBag.length} (æ•°:${this.numberBag.length} | ç¬¦:${this.operatorBag.length})`;
        this.renderRack();
    }

    showMessage(msg, isError = false) {
        const el = document.getElementById('message-area');
        el.style.color = isError ? '#ff6b6b' : '#ffd700';
        el.innerText = msg;
        el.style.transform = "scale(1.02)";
        setTimeout(() => el.style.transform = "scale(1)", 200);
    }
}

const game = new Game();
window.game = game; // æš´éœ²ç»™å…¨å±€ï¼Œä½¿HTML onclickç”Ÿæ•ˆ

/* =========================================
   MULTIPLAYER EXTENSION (Added Code)
   =========================================
*/
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.13.1/firebase-app.js";
import { getAnalytics } from "https://www.gstatic.com/firebasejs/10.13.1/firebase-analytics.js";
import { getFirestore, doc, setDoc, getDoc, onSnapshot, updateDoc } from "https://www.gstatic.com/firebasejs/10.13.1/firebase-firestore.js";
import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/10.13.1/firebase-auth.js";

// Firebase Configuration
const firebaseConfig = {
    apiKey: "AIzaSyDG8QBOaVkG2X2q04dyG0wVe-vYvsOVAdQ",
    authDomain: "g-math-pvp-35665.firebaseapp.com",
    projectId: "g-math-pvp-35665",
    storageBucket: "g-math-pvp-35665.firebasestorage.app",
    messagingSenderId: "715488897072",
    appId: "1:715488897072:web:88c73bf50912fd6c90e5f5",
    measurementId: "G-63SZM7FYCZ"
};

const app = initializeApp(firebaseConfig);
const analytics = getAnalytics(app);
const db = getFirestore(app);
const auth = getAuth(app);

let currentRoomId = null;
let myPlayerIndex = -1;
let isMultiplayer = false;

// åºåˆ—åŒ–è¾…åŠ©å‡½æ•°
function serializeTile(t) {
    return t ? { char: t.char, id: t.id, score: t.score } : null;
}
function deserializeTile(d) {
    return d ? new Tile(d.char, d.id) : null;
}

// å…¨å±€å‡½æ•°ç»‘å®šç»™HTMLæŒ‰é’®
window.createRoom = async function() {
    try {
        updateStatus("æ­£åœ¨ç™»å½• (Logging in)...");
        await signInAnonymously(auth);
        
        const roomId = Math.floor(100000 + Math.random() * 900000).toString();
        updateStatus("åˆ›å»ºæˆ¿é—´ä¸­ (Creating)...");
        
        // ä¿å­˜åˆå§‹çŠ¶æ€
        const state = {
            board: game.boardState.map(row => row.map(c => serializeTile(c))),
            players: game.players.map(p => ({
                name: p.name,
                score: p.score,
                misses: p.misses,
                active: p.active,
                rack: p.rack.map(t => serializeTile(t))
            })),
            numberBag: game.numberBag.map(t => serializeTile(t)),
            operatorBag: game.operatorBag.map(t => serializeTile(t)),
            currentPlayerIndex: 0,
            isFirstTurn: true,
            connectedCount: 1
        };
        
        await setDoc(doc(db, "games", roomId), state);
        enterGame(roomId, 0);
    } catch (e) {
        console.error("Error creating room:", e);
        updateStatus("âŒ é”™è¯¯: " + e.message);
        if (e.message.includes("permission-denied")) {
             updateStatus("âŒ æƒé™é”™è¯¯: è¯·æ£€æŸ¥ Firebase æ§åˆ¶å° Firestore è§„åˆ™");
        }
    }
}

window.joinRoom = async function() {
    const input = document.getElementById('room-input').value;
    if(input.length !== 6) {
        updateStatus("è¯·è¾“å…¥6ä½æˆ¿é—´å·");
        return;
    }
    
    try {
        updateStatus("æ­£åœ¨è¿æ¥ (Connecting)...");
        await signInAnonymously(auth);
        
        const docRef = doc(db, "games", input);
        const snap = await getDoc(docRef);
        
        if(!snap.exists()) {
            updateStatus("âŒ æˆ¿é—´ä¸å­˜åœ¨");
            return;
        }
        
        const data = snap.data();
        if(data.connectedCount >= 4) {
            updateStatus("âŒ æˆ¿é—´å·²æ»¡");
            return;
        }
        
        const newIndex = data.connectedCount;
        await updateDoc(docRef, { connectedCount: newIndex + 1 });
        enterGame(input, newIndex);
    } catch (e) {
        console.error("Error joining room:", e);
        updateStatus("âŒ è¿æ¥å¤±è´¥: " + e.message);
    }
}

function enterGame(roomId, index) {
    currentRoomId = roomId;
    myPlayerIndex = index;
    isMultiplayer = true;
    
    document.getElementById('lobby-overlay').style.display = 'none';
    game.showMessage(`å·²è¿›å…¥æˆ¿é—´: ${roomId} (ä½ æ˜¯ ${game.players[index].name})`);
    
    // å¼€å§‹ç›‘å¬åŒæ­¥
    onSnapshot(doc(db, "games", roomId), (doc) => {
        const data = doc.data();
        syncGameState(data);
    });
    
    // é’©å­ï¼šæ‹¦æˆªæ¸¸æˆæ“ä½œä»¥ä¸Šä¼ çŠ¶æ€
    hookGameLogic();
}

function syncGameState(data) {
    if (!data) return;
    
    // æ¢å¤æ•°æ®
    game.currentPlayerIndex = data.currentPlayerIndex;
    game.isFirstTurn = data.isFirstTurn;
    
    // æ¢å¤æ£‹ç›˜
    game.boardState = data.board.map((row, r) => 
        row.map((cell, c) => {
            if(!cell) return null;
            const t = deserializeTile(cell);
            return t;
        })
    );
    
    // æ¢å¤ç©å®¶
    game.players.forEach((p, i) => {
        const d = data.players[i];
        p.score = d.score;
        p.misses = d.misses;
        p.active = d.active;
        p.name = d.name;
        // åªæ›´æ–°æ‰‹ç‰Œæ•°æ®ï¼Œå¦‚æœä¸åŒ¹é…
        if(JSON.stringify(p.rack.map(t=>t.id)) !== JSON.stringify(d.rack.map(t=>t.id))) {
            p.rack = d.rack.map(t => deserializeTile(t));
        }
    });
    
    // æ¢å¤ç‰Œè¢‹
    if (game.numberBag.length !== data.numberBag.length) game.numberBag = data.numberBag.map(t => deserializeTile(t));
    if (game.operatorBag.length !== data.operatorBag.length) game.operatorBag = data.operatorBag.map(t => deserializeTile(t));
    
    // é‡æ–°æ¸²æŸ“
    game.renderBoard();
    game.renderRack();
    game.updateUI();
    
    // æç¤ºä¿¡æ¯
    if(game.currentPlayerIndex === myPlayerIndex) {
        game.showMessage("ğŸ‘‰ è½®åˆ°ä½ äº†ï¼è¯·å‡ºç‰Œ");
    } else {
        game.showMessage(`ç­‰å¾… ${game.players[game.currentPlayerIndex].name} å‡ºç‰Œ...`);
    }
}

async function pushGameState() {
    if(!currentRoomId) return;
    
    const state = {
        board: game.boardState.map(row => row.map(c => serializeTile(c))),
        players: game.players.map(p => ({
            name: p.name,
            score: p.score,
            misses: p.misses,
            active: p.active,
            rack: p.rack.map(t => serializeTile(t))
        })),
        numberBag: game.numberBag.map(t => serializeTile(t)),
        operatorBag: game.operatorBag.map(t => serializeTile(t)),
        currentPlayerIndex: game.currentPlayerIndex,
        isFirstTurn: game.isFirstTurn
    };
    
    // ä½¿ç”¨ merge é˜²æ­¢è¦†ç›– connectedCount
    await setDoc(doc(db, "games", currentRoomId), state, { merge: true });
}

function hookGameLogic() {
    // æ‹¦æˆª nextTurn (ç”¨äº playTurn, passTurn, swap)
    const originalNextTurn = game.nextTurn.bind(game);
    game.nextTurn = function(isValidMove) {
        originalNextTurn(isValidMove);
        pushGameState();
    }
    
    // æ‹¦æˆªç‚¹å‡»ï¼Œé˜²æ­¢éå›åˆæ“ä½œ
    const originalHandleBoardClick = game.handleBoardClick.bind(game);
    game.handleBoardClick = function(r, c) {
        if(game.currentPlayerIndex !== myPlayerIndex) {
            game.showMessage("ğŸš« è¿˜æ²¡è½®åˆ°ä½ ï¼", true);
            return;
        }
        originalHandleBoardClick(r, c);
    }
    
    // æ‹¦æˆªæŒ‰é’®æ“ä½œ
    const protectButtons = ['playTurn', 'passTurn', 'toggleSwapMode', 'recallTiles'];
    // ç”±äºHTML onclickç›´æ¥è°ƒç”¨ game.methodï¼Œæˆ‘ä»¬æ›¿æ¢è¿™äº›æ–¹æ³•
    protectButtons.forEach(method => {
        const original = game[method].bind(game);
        game[method] = function(...args) {
            if(game.currentPlayerIndex !== myPlayerIndex && method !== 'recallTiles') { // recallTiles å…è®¸æœ¬åœ°è°ƒæ•´
                game.showMessage("ğŸš« è¿˜æ²¡è½®åˆ°ä½ ï¼", true);
                return;
            }
            original(...args);
        }
    });
}

function updateStatus(msg) {
    document.getElementById('lobby-status').innerText = msg;
}

</script>
</body>
</html>
